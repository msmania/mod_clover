/* 
**  mod_clover.c -- Apache sample clover module
**  [Autogenerated via ``apxs -n clover -g'']
**
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "apr_strings.h"

#define LODWORD(ll) (((long long)(ll))&0xffffffff)
#define HIDWORD(ll) ((((long long)(ll))>>32)&0xffffffff)
#define LLP(p) HIDWORD(p), LODWORD(p)

#define LOGDEBUG

static const char FILTER_NAME[]="CLOVER";

/*
   DocType

   0 - No DOCTYPE
   1 - HTML 5
   2 - HTML 4.01 Strict
   3 - HTML 4.01 Transitional
   4 - HTML 4.01 Frameset
   5 - XHTML 1.0 Strict
   6 - XHTML 1.0 Transitional
   7 - XHTML 1.0 Frameset
   8 - XHTML 1.1
 */

enum HTML_DOCTYPE {
    doctype_NA = 0,
    doctype_HTML5,
    doctype_HTML401Strict,
    doctype_HTML401Transitional,
    doctype_HTML401Frameset,
    doctype_XHTML10Strict,
    doctype_XHTML10Transitional,
    doctype_XHTML10Frameset,
    doctype_XHTML11,
    doctype_Sentinel
};

static const char HTML_DOCMODE_TEMPLATE[] = "<meta http-equiv=\"x-ua-compatible\" content=\"IE=%s\">\n";
static const char HTML_DOCTYPES[][150] = {
    "",
    "<!DOCTYPE html>\n",
    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n",
    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n",
    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\n",
    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n",
    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n",
    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n",
    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n"
};

static void *create_config(apr_pool_t *pool, char *x);
static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add);
static void clover_register_hooks(apr_pool_t *p);

typedef struct {
    apr_bucket_brigade *passbb;
    apr_bucket_brigade *snippets;
    apr_pool_t *subpool;

    ap_regex_t *regex_doctype;
    ap_regex_t *regex_docmode;

    const char *doctype;
    const char *docmode;
    int processed_doctype;
    int processed_docmode;
} filter_context;

typedef struct {
    int dynamic;
    const char *doctype;
    const char *docmode;
} module_config;

static const command_rec commands_table[] = {
    AP_INIT_TAKE1("Clover_DocType", ap_set_string_slot,
                  (void*)APR_OFFSETOF(module_config, doctype), OR_ALL,
                  "HTML <!DOCTYPE> Declaration"),
    AP_INIT_TAKE1("Clover_DocMode", ap_set_string_slot,
                  (void*)APR_OFFSETOF(module_config, docmode), OR_ALL,
                  "Document mode for IE"),
    AP_INIT_TAKE1("Clover_Dynamic", ap_set_int_slot,
                  (void*)APR_OFFSETOF(module_config, dynamic), OR_ALL,
                  "Control via a query string if the value is non-zernon-zero"),
    {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA clover_module = {
    STANDARD20_MODULE_STUFF, 
    create_config,         /* create per-dir    config structures */
    merge_config,          /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    commands_table,        /* table of config file commands       */
    clover_register_hooks  /* register hooks                      */
};

static void logging(filter_context *context, request_rec *request, const char *format, ...) {
    va_list vargs;
    const char *message = NULL;

    va_start(vargs, format);
    message = apr_pvsprintf(context->subpool, format, vargs);
    va_end(vargs);

    printf("%s\n", message);
}

static void *create_config(apr_pool_t *pool, char *x) {
    return apr_pcalloc(pool, sizeof(module_config));
}

static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add) {
    module_config *base = (module_config*)in_base;
    module_config *add = (module_config*)in_add;

    module_config *newconfig = apr_palloc(pool, sizeof(module_config));
    newconfig->doctype = add->doctype ? add->doctype : base->doctype;
    newconfig->docmode = add->docmode ? add->docmode : base->docmode;
    newconfig->dynamic = add->dynamic;

    return newconfig;
}

static void *init_context(ap_filter_t *f) {
    if ( !f->ctx ) {
        filter_context *context = f->ctx = apr_palloc(f->r->pool, sizeof(filter_context));
        module_config *config = ap_get_module_config(f->r->per_dir_config, &clover_module);
        module_config effective;

        memset(context, 0, sizeof(context));
        memset(&effective, 0, sizeof(effective));

        apr_pool_create(&context->subpool, f->r->pool);

        context->passbb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);
        context->snippets = apr_brigade_create(f->r->pool, f->c->bucket_alloc);

        context->regex_doctype = apr_pcalloc(f->r->pool, sizeof(ap_regex_t));
        if ( context->regex_doctype &&
             ap_regcomp(context->regex_doctype, "^<\\!DOCTYPE html", AP_REG_ICASE)!=0 ) {
            context->regex_doctype = NULL;
            logging(context, f->r, "ap_regcomp for doctype failed.");
        }

        context->regex_docmode = apr_pcalloc(f->r->pool, sizeof(ap_regex_t));
        if ( context->regex_docmode &&
             ap_regcomp(context->regex_docmode, "^\\s*<meta http-equiv=\"x-ua-compatible\"", AP_REG_ICASE)!=0 ) {
            context->regex_docmode = NULL;
            logging(context, f->r, "ap_regcomp for docmode failed.");
        }

        if ( config->dynamic ) {
            const char delim[] = "&";
            char *querystring = apr_psprintf(context->subpool, "%s", f->r->parsed_uri.query);
            char *pair = NULL;
            char *last = NULL;
            for ( pair = apr_strtok(querystring, delim, &last);
                  pair;
                  pair = apr_strtok(NULL, delim, &last) ) {
                if ( (pair[0]=='t' || pair[0]=='T') && pair[1]=='=' ) {
                    pair += 2;
                    effective.doctype = pair;
                }
                else if ( (pair[0]=='m' || pair[0]=='M') && pair[1]=='=' ) {
                    pair += 2;
                    effective.docmode = pair;
                }
            }
        }
        else {
            effective.doctype = config->doctype;
            effective.docmode = config->docmode;
        }

        if ( effective.doctype ) {
            int doctype_num = atoi(effective.doctype);
            context->doctype = doctype_num < doctype_Sentinel ? HTML_DOCTYPES[doctype_num] : "";
        }
        else {
            context->doctype = NULL;
        }

        context->docmode = effective.docmode ? apr_psprintf(f->r->pool, HTML_DOCMODE_TEMPLATE, effective.docmode) : NULL;
        context->processed_doctype = 0;
        context->processed_docmode = 0;

        LOGDEBUG(context, f->r, "effective.doctype = %s", effective.doctype);
        LOGDEBUG(context, f->r, "effective.docmode = %s", effective.docmode);
        LOGDEBUG(context, f->r, "context->doctype = %s", context->doctype);
        LOGDEBUG(context, f->r, "context->docmode = %s", context->docmode);
    }

    return f->ctx;
}

static int match_line(ap_regex_t *regex, const char *line) {
    ap_regmatch_t pmatch[10];
    return regex ? (ap_regexec(regex, line, 10, pmatch, 0)==0) : 0;
}

static apr_status_t clover_handler(ap_filter_t *f, apr_bucket_brigade *bb) {
    apr_status_t status = APR_SUCCESS;
    apr_bucket *b = NULL;
    apr_bucket *nextbucket = NULL;
    filter_context *context = (filter_context*)f->ctx;

    if ( context==NULL ) {
        context = init_context(f);
        apr_table_unset(f->r->headers_out, "Content-Length");
    }

    // Workaround: It seems that apr_pvsprintf cannot take a 64bit value
    LOGDEBUG(context, f->r, "ENTERING clover_handler (ctx=0x%08x%08x)", LLP(context));

    if ( APR_BRIGADE_EMPTY(bb) ) {
        return APR_SUCCESS;
    }

    for ( b = APR_BRIGADE_FIRST(bb);
          b != APR_BRIGADE_SENTINEL(bb); ) {
        nextbucket = APR_BUCKET_NEXT(b);

        if ( !APR_BUCKET_IS_EOS(b) && !APR_BUCKET_IS_METADATA(b) && !APR_BUCKET_IS_FLUSH(b) ) {
            // Processing data bucket...
            const char *data = NULL;
            apr_size_t bucketlength = 0;

            status = apr_bucket_read(b, &data, &bucketlength, APR_BLOCK_READ);
            if ( status!=APR_SUCCESS || bucketlength==0 ) {
                // If data cannot be retrieved from a bucket, just ignore it.
            }
            else {
                while ( bucketlength>0 ) {
                    const char *newline = memchr(data, APR_ASCII_LF, bucketlength);
                    if ( !newline ) {
                        APR_BUCKET_REMOVE(b);
                        APR_BRIGADE_INSERT_TAIL(context->snippets, b);
                        bucketlength = 0;
                    }
                    else {
                        apr_size_t linelength = 0;
                        char *linestr = NULL;
                        const char *replaced_line = NULL;

                        apr_size_t len_to_newline = (apr_size_t)(newline-data)+1;

                        if ( len_to_newline<bucketlength ) {
                            //
                            // No need to update nextbucket here.
                            //
                            // before split: b --> nextbucket
                            // after split:  b --> newbucket --> nextbucket
                            // remove b
                            // assign a value of newbucket to nextbucket
                            //
                            apr_bucket *newbucket = NULL;

                            apr_bucket_split(b, len_to_newline);
                            newbucket = APR_BUCKET_NEXT(b);

                            APR_BUCKET_REMOVE(b);
                            APR_BRIGADE_INSERT_TAIL(context->snippets, b);

                            b = newbucket;

                            data += len_to_newline;
                            bucketlength -= len_to_newline;
                        }
                        else {
                            // reaches the end of bucket
                            APR_BUCKET_REMOVE(b);
                            APR_BRIGADE_INSERT_TAIL(context->snippets, b);
                            bucketlength = 0;
                        }

                        status = apr_brigade_pflatten(context->snippets, &linestr, &linelength, context->subpool);
                        if ( status!=APR_SUCCESS ) {
                            logging(context, f->r, "apr_brigade_pflatten failed - %d\n", (int)status);
                            goto cleanup;
                        }

                        if ( !context->processed_doctype && match_line(context->regex_doctype, linestr) ) {
                            replaced_line = context->doctype;
                            linelength = replaced_line ? strlen(replaced_line) : linelength;
                        }

                        // If the first line is not DOCTYPE, we don't need to check DOCTYPE anymore.
                        context->processed_doctype = 1;

                        if ( !context->processed_docmode && match_line(context->regex_docmode, linestr) ) {
                            replaced_line = context->docmode;
                            linelength = replaced_line ? strlen(replaced_line) : linelength;
                            context->processed_docmode = 1;
                        }

                        APR_BRIGADE_INSERT_TAIL(context->passbb,
                            apr_bucket_transient_create(
                                replaced_line ? replaced_line : linestr,
                                linelength, f->r->connection->bucket_alloc));

                        apr_brigade_cleanup(context->snippets);
                    }
                } // sub loop
            }
        }
        else {
            // If a bucket is not a data bucket, simply passes it to the next filter.
            APR_BUCKET_REMOVE(b);
            APR_BRIGADE_INSERT_TAIL(context->passbb, b);
        }

        if ( !APR_BRIGADE_EMPTY(context->passbb) ) {
            status = ap_pass_brigade(f->next, context->passbb);
            apr_brigade_cleanup(context->passbb);
            apr_pool_clear(context->subpool);
        }
        b = nextbucket;
    } // main loop

cleanup:
    LOGDEBUG(context, f->r, "LEAVING clover_handler (ctx=0x%08x%08x)", LLP(context));

    apr_pool_clear(context->subpool);

    return status;
}

static void clover_register_hooks(apr_pool_t *p)
{
    // It's ok to use the 3rd parameter for init_context, but ap_init_context_func cannot be used
    // to update the value of Content-Length from. Content-Length should be updated from the
    // first call of handler. This means that we need to check the context is NULL or not
    // before the main loop in handler.  In this case, it's simpler to call init_context from
    // handler directly and not to use ap_init_context_func here.
    ap_register_output_filter(FILTER_NAME, clover_handler, NULL, AP_FTYPE_RESOURCE);
}

